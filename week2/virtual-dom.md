# 3. Virtual DOM

## 강의 요약 및 노트

- Virtual DOM. 가상의 돔
- 화면을 갱신하기 위해서는 DOM을 갱신해야 함
- Virtual DOM(VDOM)은 UI의 이상/가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화 하는 프로그래밍 개념. -> 이를 재조정이라고 함  
https://ko.reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom

- 리액트가 선언적 API를 제공해준다는 의미 -> 우리가 이제까지 작성한 코드를 보면 어떤 부분이 바뀔 것이고 어떤 부분은 바뀌지 않을 것이라는 내용이 들어있지 않음. 즉 우리는 만들고자 하는 element들, 컴포넌트를 선언만 했을 뿐.  
이에 따라 선언한 엘리먼트, 컴포넌트들이 VDOM에 적용되고 실제 DOM과 VDOM이 비교해나가면서 바뀐 부분에 대해서만 재조정!

- Dev tools 소개. 리액트 DOM tree를 비슷하게 보는 느낌을 주는 tool -> `react-developer-tools`

- 궁금. nullish(`??`). 이거 찾아봐야지.

- VDOM 왜 사용하나? -> 나도 보통 '빠르다'라고 들었던 것 같다. 하지만 진짜 중요한 건 그게 아니다. 이미 충분히 빠름. 대부분의 경우에는! 결국엔 유지보수가 가능하고 유지보수 하기 좋은 어플리케이션을 만들 수 있다는 것이 핵심!

- 적절한 빠르기를 내면서도 적절하게 관리할 수 있고, 유지보수가 가능한 애플리케이션을 만들 때 어디에 균형점을 잡는 것이 좋을까? -> 그렇게 했을 때 리액트가 선택한 방법은 VDOM. 빠르기 때문에만 선택한 것은 아님. 왜냐면 막 짜는 것보다는 VDOM이 충분히 빠르기 때문.

- 결국엔 궁극적으로 무엇을 하기 위해 DOM을 사용하는가 -> React의 선언적 API를 가능하게 하는 것.

- VDOM이 무엇이고, 왜 쓰는지를 안다면 활용할 수 있는 최적화 기법이 존재하며 이를 통해 최적화를 계속 해나갈 수 있음

---

## 키워드 정리

### VDOM(Virtual DOM)이란?

1. DOM이란?

- DOM은 Document Object Model의 약자로, HTML, XMS 문서에 접근하기 위한 일종의 프로그래밍 인터페이스라고 할 수 있음
- 텍스트파일로 만들어진 웹 문서를 브라우저에 렌더링하려면? -> 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 할 것임. 브라우저의 렌더링 엔진은 웹 문서를 로드한 후 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라고 함.
- XML, HTML 문서의 각 항목을 계층, 즉 트리 형식으로 표현하여 사용자가 이를 생성하거나, 변형하거나, 또는 삭제할 수 있도록 도움.  
모든 요소, 어트리뷰트, 텍스트가 각각의 객체로 변환되며 이 객체를 부-자(parent-child) 관계로 표현 가능한 트리 구조로 구성한 것
- DOM을 사용하면 이 요소들을 오브젝트(객체)로 다룰 수 있음. 또한 자바스크립트와 같은 스크립팅 언어를 이용해 DOM 수정이 가능함

2. DOM과 Virtual DOM의 차이

- VDOM은 UI의 이상적인, 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화 하는 프로그래밍 개념
- DOM은 데이텈가 변경될 때마다 매번 처음부터 다시 화면이 그려지는 불필요한 반복이 발생됨. 다만 React가 선택한 VDOM은 컴포넌트나 state 등의 변경 시 바로 DOM에 다시 그려주는 것이 아니라 먼저 VDOM에 그림. 그리고 나서 해당 스냅샷을 통해 기존의 DOM과 비교한 뒤 변경된 부분만을 다시 그려주므로 효율적인 DOM조작이 가능할 것임

### Reconciliation(재조정) 과정은 무엇인가?

- UI의 이상/가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화 하는 과정을 재조정이라고 함
- 재조정 시의 '비교 알고리즘(diffing algorithm)' 에 대한 기본적인 이해가 필요할 것+_+  

- 두 개의 트리 비교 시, 리액트는 두 엘리먼트의 루트(root) 엘리먼트부터 비교함. 이에 따라 동작이 달라짐
    - 엘리먼트 타입이 다른 경우: 이전 트리를 버리고 완전히 새로운 트리를 구축(예. `<a>`가 `<img>`로 바뀌거나, `<Button>`이 `<Comment>`로 바뀌는 등)  
    루트 엘리먼트 아래의 모든 컴포넌트도 언마운트, 그 state도 사라짐
    - 엘리먼트 타입이 같은 경우: 타입이 같으면 두 엘리먼트의 속성(attribute)을 확인하여 동일한 내역은 유지, 변경된 속성들만 갱신함

- DOM 노드의 자식들을 재귀적으로 처리할 때, 자식들이 가진 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인함  
key는 오로지 형제 사이에서만 유일하면 되고, 전역에서 유일할 필요는 없음.  
배열의 인덱스를 key로 사용할 수는 있으나 재배열 될 가능성, 배열의 재배열 후 발생하는 side-effect 때문에 사용하지 않을 것을 권장
